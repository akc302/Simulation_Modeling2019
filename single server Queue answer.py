# -*- coding: utf-8 -*-
"""011-171-153 SSQ.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11w5nl3iXqcyFrECH5C6hck1TOskPer7j
"""

#Ashraf ID: 011171153
#SSQ FINAL ASSESSSMENT!

import numpy as np
import matplotlib.pyplot as plt
import math,queue
np.random.seed(2)

from queue import LifoQueue 

def server_fifo(n,pa,ps):
    q = queue.Queue()
    serverBusy = 0
    cDelay = 0
    exp_customer=0
    utilization=0
    customersServed=0
    
    inf = float('inf')
    

    currentTime = 0
    
    interarrivalTime = np.random.geometric(pa)
    arrivalTime = currentTime + interarrivalTime
    departureTime = inf

    #i=0
    start_T=currentTime
    while customersServed < n:
        
        previousT=currentTime
        if arrivalTime < departureTime:
            currentTime = arrivalTime
        else:
            currentTime = departureTime
        
        exp_customer=exp_customer+(currentTime-previousT)*q.qsize()
        utilization=utilization+(currentTime-previousT)*serverBusy
        
        

        if currentTime == arrivalTime:
            currentTime = arrivalTime
            if serverBusy == 0:
                
                serverBusy = 1

                serviceTime = np.random.geometric(ps)
                departureTime = currentTime + serviceTime
            else:
                q.put(currentTime)
                
            interarrivalTime = np.random.geometric(pa)
            arrivalTime = currentTime + interarrivalTime
        else:
            customersServed = customersServed + 1
            serverBusy = 0

            if(q.qsize()!=0):
                jobDeparts = q.get(0)

                cDelay = cDelay + (currentTime - jobDeparts)
                serviceTime = np.random.geometric(ps)
                departureTime = currentTime + serviceTime


            else:
    
                departureTime = inf
        
        #print("previous time:", previousT, "currentTime: ",currentTime, "queue length",q.qsize(), "q(t):",exp_customer,"b(t):",utilization)

    return cDelay/n,exp_customer/(currentTime-start_T),utilization/(currentTime-start_T)
    
def server_lifo(n,pa,ps):
    q=LifoQueue()  
    serverBusy = 0
    cDelay = 0
    exp_customer=0
    utilization=0
    customersServed=0
    
    inf = float('inf')
    

    currentTime = 0
    
    interarrivalTime = np.random.geometric(pa)
    arrivalTime = currentTime + interarrivalTime
    departureTime = inf
    start_T=currentTime
    while customersServed < n:
            
            previousT=currentTime
            if arrivalTime < departureTime:
                currentTime = arrivalTime
            else:
                currentTime = departureTime
            
            exp_customer=exp_customer+(currentTime-previousT)*q.qsize()
            utilization=utilization+(currentTime-previousT)*serverBusy
            
            

            if currentTime == arrivalTime:
                currentTime = arrivalTime
                if serverBusy == 0:
                    
                    serverBusy = 1

                    serviceTime = np.random.geometric(ps)
                    departureTime = currentTime + serviceTime
                else:
                    q.put(currentTime)
                    
                interarrivalTime = np.random.geometric(pa)
                arrivalTime = currentTime + interarrivalTime
            else:
                customersServed = customersServed + 1
                serverBusy = 0

                if(q.qsize()!=0):
                    jobDeparts = q.get()

                    cDelay = cDelay + (currentTime - jobDeparts)
                    serviceTime = np.random.geometric(ps)
                    departureTime = currentTime + serviceTime


                else:
    
                    departureTime = inf
    return cDelay/n,exp_customer/(currentTime-start_T),utilization/(currentTime-start_T)

def server_sjf(n,pa,ps):
        q=[]  
        serverBusy = 0
        cDelay = 0
        exp_customer=0
        utilization=0
        customersServed=0
        
        inf = float('inf')
        #individual_delay = []

        currentTime = 0
        
        interarrivalTime = np.random.geometric(pa)
        arrivalTime = currentTime + interarrivalTime
        departureTime = inf
        start_T=currentTime
        while customersServed < n:
                
                previousT=currentTime
                if arrivalTime < departureTime:
                    currentTime = arrivalTime
                else:
                    currentTime = departureTime
                
                exp_customer=exp_customer+(currentTime-previousT)*len(q)
                utilization=utilization+(currentTime-previousT)*serverBusy
                
                

                if currentTime == arrivalTime:
                    currentTime = arrivalTime
                    if serverBusy == 0:
                        
                        serverBusy = 1

                        serviceTime = np.random.geometric(ps)
                        departureTime = currentTime + serviceTime
                    else:
                        serviceTime = np.random.geometric(ps)
                        q.append((serviceTime,currentTime))

                        q.sort()    
                        
                    interarrivalTime = np.random.geometric(pa)
                    arrivalTime = currentTime + interarrivalTime
                else:
                    customersServed = customersServed + 1
                    serverBusy = 0

                    if(len(q)!=0):
                        #q.sort()    
                        w=q.pop(0)
                        jobDeparts = w[1]

                        cDelay = cDelay + (currentTime - jobDeparts)
                        serviceTime = np.random.geometric(ps)
                        departureTime = currentTime + serviceTime


                    else:
        
                        departureTime = inf
        return cDelay/n,exp_customer/(currentTime-start_T),utilization/(currentTime-start_T)

lifo_delay,lifo_exp,lifo_utilization=server_lifo(6,.2,.3)
fifo_delay,fifo_exp,fifo_utilization=server_fifo(6,.2,.3)
sjf_delay,sjf_exp,sjf_utilization=server_sjf(6,.2,.3)

print("lifo avrg delay:",lifo_delay, "lifo expected customer:",lifo_exp,"lifo utilization:",lifo_utilization)
print("fifo avrg delay:",fifo_delay,"fifo expected customer:",fifo_exp,"fifo utilization:",fifo_utilization)
print("sjf avrg delay:",sjf_delay,"sjf expected customer:",sjf_exp,"sjf utilization:",sjf_utilization)

#graph ploting functions
#ed,eq,eu=return value from the lifo,fifo,sjf function
#a is a list with some value of pa
def graph_ED(a,ED):
  fig, ax = plt.subplots()
  for i in range(0,len(a)):
    plt.plot([a[i],a[i]],[0,ED[i]],color='blue')
  ax.set_xlabel('~~~~Arrival rate~~~~')
  ax.set_ylabel('~~~~Average delay E[D]~~~~')
  plt.show()

def graph_EQ(a,EQ):
  fig, ax = plt.subplots()
  for i in range(0,len(a)):
    plt.plot([a[i],a[i]],[0,EQ[i]],color='red')
  ax.set_xlabel('~~~~Arrival rate~~~~')
  ax.set_ylabel('Exppected Number of Customer in queue,E[Q]')
  plt.show()

def graph_EU(a,EU):
  fig, ax = plt.subplots()
  for i in range(0,len(a)):
    plt.plot([a[i],a[i]],[0,EU[i]],color='blue')
  ax.set_xlabel('~~~~Arrival rate~~~~')
  ax.set_ylabel('~~~~Utilization of the server,E[U]~~~~')
  plt.show()



max_serverUtilization=max(lifo_utilization,max(fifo_utilization,sjf_utilization))
print(max_serverUtilization)
li=[]
for i in range(1,10):
  li.append(i/100)
print(li)   
pa=li

#initialize the queue for the graph
ed=[]
eu=[]
eq=[]


if max_serverUtilization==lifo_utilization:
    for i in range(0,len(pa)):
        lifo_delay,lifo_exp,lifo_utilization=server_lifo(50,pa[i],.3)
        print("~~~~~~~~~~~~lifo delay:~~~~~~~~~", lifo_delay)
        ed.append(lifo_delay)
        eq.append(lifo_exp)
        eu.append(lifo_utilization)
    print("~~~~~~~~~~~for lifo n=50~~~~~~~~~~")    
    graph_ED(pa,ed)

    graph_EQ(pa,eq)

    graph_EU(pa,eu)
    #clear the list
    ed.clear()
    eq.clear()
    eu.clear()

    
    for i in range(0,len(pa)):
        lifo_delay,lifo_exp,lifo_utilization=server_lifo(100,pa[i],.3)
        ed.append(lifo_delay)
        eq.append(lifo_exp)
        eu.append(lifo_utilization)
    print("~~~~~~~~~~~~~for lifo  n=100~~~~~~~~~~~~~")    
    graph_ED(pa,ed)

    graph_EQ(pa,eq)

    graph_EU(pa,eu)
    #clear the list
    ed.clear()
    eq.clear()
    eu.clear()
elif max_serverUtilization==fifo_utilization:
    for i in range(0,len(pa)):
        fifo_delay,fifo_exp,fifo_utilization=server_fifo(50,pa[i],.3)
        ed.append(fifo_delay)
        eq.append(fifo_exp)
        eu.append(fifo_utilization)
    print("~~~~~~~~~~~~~for fifo n=50~~~~~~~~~~~~~")    
    graph_ED(pa,ed)

    graph_EQ(pa,eq)

    graph_EU(pa,eu)
    #clear the list
    ed.clear()
    eq.clear()
    eu.clear()

    print("~~~~~~~~~~~~for fifo  n=100~~~~~~~~~~~~~")
    for i in range(0,len(pa)):
        fifo_delay,fifo_exp,fifo_utilization=server_fifo(100,pa[i],.3)
        ed.append(fifo_delay)
        eq.append(fifo_exp)
        eu.append(fifo_utilization)
    print("for n=50")    
    graph_ED(pa,ed)

    graph_EQ(pa,eq)

    graph_EU(pa,eu)
    #clear the list
    ed.clear()
    eq.clear()
    eu.clear()

else:
    for i in range(0,len(pa)):
        sjf_delay,sjf_exp,sjf_utilization=server_sjf(50,pa[i],.3)

        ed.append(sjf_delay)
        eq.append(sjf_exp)
        eu.append(sjf_utilization)
    print("~~~~~~~~~~~for sjf n=50~~~~~~~~~~")    
    graph_ED(pa,ed)

    graph_EQ(pa,eq)

    graph_EU(pa,eu)
    #clear the list
    ed.clear()
    eq.clear()
    eu.clear()

    print("~~~~~~~~~~for sjf n=100~~~~~~~~~~")
    for i in range(0,len(pa)):
        sjf_delay,sjf_exp,sjf_utilization=server_sjf(100,pa[i],.3)
        ed.append(sjf_delay)
        eq.append(sjf_exp)
        eu.append(sjf_utilization)
    print("for n=50")    
    graph_ED(pa,ed)

    graph_EQ(pa,eq)

    graph_EU(pa,eu)
    #clear the list
    ed.clear()
    eq.clear()
    eu.clear()

